"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.u8aToBigInt = void 0;
const x_bigint_1 = require("@polkadot/x-bigint");
const consts_js_1 = require("../bi/consts.js");
const U8_MAX = (0, x_bigint_1.BigInt)(256);
const U16_MAX = (0, x_bigint_1.BigInt)(256 * 256);
const U64_MAX = (0, x_bigint_1.BigInt)('0x10000000000000000');
/**
 * @name u8aToBigInt
 * @summary Creates a BigInt from a Uint8Array object.
 */
function u8aToBigInt(value, { isLe = true, isNegative = false } = {}) {
    // BE is not the optimal path - LE is the SCALE default
    const u8a = isLe
        ? value
        : value.slice().reverse();
    const count = u8a.length;
    if (isNegative) {
        switch (count) {
            case 0:
                return (0, x_bigint_1.BigInt)(0);
            case 1:
                return (0, x_bigint_1.BigInt)(((u8a[0] ^ 255) * -1) - 1);
            case 2:
                return (0, x_bigint_1.BigInt)((((u8a[0] + (u8a[1] << 8)) ^ 65535) * -1) - 1);
            case 4:
                return (0, x_bigint_1.BigInt)((((u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + (u8a[3] * 16777216)) ^ 4294967295) * -1) - 1);
        }
        const dvI = new DataView(u8a.buffer, u8a.byteOffset);
        if (count === 8) {
            return dvI.getBigInt64(0, true);
        }
        let result = (0, x_bigint_1.BigInt)(0);
        const mod = count % 2;
        for (let i = count - 2; i >= mod; i -= 2) {
            result = (result * U16_MAX) + (0, x_bigint_1.BigInt)(dvI.getUint16(i, true) ^ 0xffff);
        }
        if (mod) {
            result = (result * U8_MAX) + (0, x_bigint_1.BigInt)(u8a[0] ^ 0xff);
        }
        return (result * -consts_js_1._1n) - consts_js_1._1n;
    }
    switch (count) {
        case 0:
            return (0, x_bigint_1.BigInt)(0);
        case 1:
            return (0, x_bigint_1.BigInt)(u8a[0]);
        case 2:
            return (0, x_bigint_1.BigInt)(u8a[0] + (u8a[1] << 8));
        case 4:
            return (0, x_bigint_1.BigInt)(u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + (u8a[3] * 16777216));
    }
    const dvI = new DataView(u8a.buffer, u8a.byteOffset);
    switch (count) {
        case 8:
            return dvI.getBigUint64(0, true);
        case 16:
            return (dvI.getBigUint64(8, true) * U64_MAX) + dvI.getBigUint64(0, true);
        default: {
            let result = (0, x_bigint_1.BigInt)(0);
            const mod = count % 2;
            for (let i = count - 2; i >= mod; i -= 2) {
                result = (result * U16_MAX) + (0, x_bigint_1.BigInt)(dvI.getUint16(i, true));
            }
            if (mod) {
                result = (result * U8_MAX) + (0, x_bigint_1.BigInt)(u8a[0]);
            }
            return result;
        }
    }
}
exports.u8aToBigInt = u8aToBigInt;
