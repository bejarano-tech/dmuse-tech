import { BN } from '@polkadot/util';
export * from '@polkadot/util';
import { B as BasicMetadataFile } from './useMetadata-a5a897cb.js';
import { AbiParam } from '@polkadot/api-contract/types';
import { ApiBase } from '@polkadot/api/types';
import { T as TransactionStatus, D as DecodedContractResult, j as CallInfo, g as DecodedTxResult, d as TxInfo } from './contracts-5e7fdfd7.js';
export { b as MetadataError, V as Validation, v as validateMetadata } from './jsonToAbi-312b7654.js';
import { EventRecord, DispatchError, DispatchInfo, Balance } from '@polkadot/types/interfaces';
import { I as IRegistryInfo, a as CallResult, C as Contract, R as RegistryErrorMethod } from './tokens-f0d70f39.js';
import './chains.js';
import '@polkadot/api-contract';

declare const toBasicMetadata: (file: File) => Promise<BasicMetadataFile>;

type JSType = 'BN' | 'Bytes' | 'boolean' | 'null' | 'number' | 'string';
type TypeDefType = string;
type RegistryTypesMap = Record<TypeDefType, JSType>;
declare const toJSType: (abiParam: AbiParam) => [TypeDefType, JSType | undefined];

declare const toMessageParams: (api: ApiBase<'promise'>, abiParams: AbiParam[], userParams?: Record<string, unknown> | null) => unknown[];

type Response = {
    status: TransactionStatus;
};
declare const isNone: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isDryRun: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isPendingSignature: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isErrored: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isFuture: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isReady: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isBroadcast: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isRetracted: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isFinalityTimeout: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isInBlock: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isFinalized: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isUsurped: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isDropped: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const isInvalid: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const hasAny: (tx: {
    status: TransactionStatus;
}, ...statuses: TransactionStatus[]) => boolean;
declare const shouldDisable: (tx: {
    status: TransactionStatus;
}) => boolean;
declare const shouldDisableStrict: (tx: {
    status: TransactionStatus;
}) => boolean;

interface IEvent {
    name: string;
}

interface ContractInstantiated extends IEvent {
    deployer: string;
    contractAddress: string;
}
declare const isContractInstantiatedEvent: ({ event }: EventRecord) => boolean;
declare const asContractInstantiatedEvent: (eventRecord: EventRecord) => ContractInstantiated | undefined;

declare const formatEventName: ({ event }: EventRecord) => string;

type ExtrinsicFailedEvent = EventRecord & {
    name: string;
    event: {
        data: {
            dispatchError: DispatchError;
            dispatchInfo: DispatchInfo;
        };
    };
};
declare const isExtrinsicFailedEvent: ({ event }: EventRecord) => boolean;
declare const asExtrinsicFailedEvent: (event: EventRecord) => ExtrinsicFailedEvent | undefined;
declare const formatExtrinsicFailed: (event: EventRecord, api: ApiBase<'promise'> | undefined) => string | undefined;

declare const NOOP: () => void;

declare const encodeSalt: (salt?: Uint8Array | string) => Uint8Array;

interface FileState {
    name: string;
    size?: number;
}
declare const formatFileName: ({ name, size }: FileState) => string;

type CreatedItem = {
    createdAt: number;
};
declare function getExpiredItem<T>(items: CreatedItem[], expirationPeriod?: number): T[];

declare const isTxCancelledError: (e?: unknown) => boolean;

declare const isValidHash: (value: string | undefined, length?: number) => boolean;

declare const stringNumberToBN: (valWithCommas: string) => BN;
declare const planckToDecimal: (amount: undefined | string | number | number[] | BN | Uint8Array | Buffer, api: IRegistryInfo | undefined) => number | undefined;
interface PlanckToDecimalOptions {
    decimals: number;
}
declare const planckToDecimalFormatted: (amount: undefined | string | number | number[] | BN | Uint8Array | Buffer, api: IRegistryInfo | undefined, options?: PlanckToDecimalOptions) => string | undefined;
declare const decimalToPlanck: (amount: number, api: IRegistryInfo | undefined) => BigInt | undefined;

declare const pseudoRandomHex: (size?: number) => string;

declare const pseudoRandomId: (t?: number) => string;

declare const pseudoRandomU8a: (t?: number) => Uint8Array;

declare const unixMilliToDate: (unixInMilliSeconds: number | undefined) => Date | undefined;

declare function pickCallInfo<T>(decoded: DecodedContractResult<T> | undefined): CallInfo | undefined;

declare function pickDecoded<T>(decoded: DecodedContractResult<T> | undefined): T | undefined;

declare function pickDecodedError(call: CallResult | undefined, contract: Contract, moduleMessages?: Record<RegistryErrorMethod, string>, defaultMessage?: string): string | undefined;

declare function pickError<T>(decoded: DecodedContractResult<T> | undefined): DispatchError | undefined;

declare function pickResultErr<T, E>(decoded: DecodedContractResult<T & {
    Err?: E;
}> | undefined): E | undefined;

declare function pickResultOk<T, K>(decoded: DecodedContractResult<T & {
    Ok?: K;
}> | undefined): K | undefined;

declare function pickTxInfo(result: DecodedTxResult<unknown> | undefined): TxInfo | undefined;

declare const bnToBalance: (api: Pick<ApiBase<'promise'>, 'createType'> | undefined, bn: BN | undefined) => Balance | undefined;

type RustResult<T, E> = {
    Ok?: T;
    Err?: E;
};

export { ContractInstantiated, CreatedItem, ExtrinsicFailedEvent, JSType, NOOP, RegistryTypesMap, Response, RustResult, TypeDefType, asContractInstantiatedEvent, asExtrinsicFailedEvent, bnToBalance, decimalToPlanck, encodeSalt, formatEventName, formatExtrinsicFailed, formatFileName, getExpiredItem, hasAny, isBroadcast, isContractInstantiatedEvent, isDropped, isDryRun, isErrored, isExtrinsicFailedEvent, isFinalityTimeout, isFinalized, isFuture, isInBlock, isInvalid, isNone, isPendingSignature, isReady, isRetracted, isTxCancelledError, isUsurped, isValidHash, pickCallInfo, pickDecoded, pickDecodedError, pickError, pickResultErr, pickResultOk, pickTxInfo, planckToDecimal, planckToDecimalFormatted, pseudoRandomHex, pseudoRandomId, pseudoRandomU8a, shouldDisable, shouldDisableStrict, stringNumberToBN, toBasicMetadata, toJSType, toMessageParams, unixMilliToDate };
