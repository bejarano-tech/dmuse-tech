import {
  RococoContractsTestnet
} from "./chunk-USPRARIS.mjs";
import {
  FIVE_SECONDS,
  HALF_A_SECOND,
  useInterval,
  useIsMounted
} from "./chunk-ABVRVYC3.mjs";
import {
  Abi,
  ApiPromise,
  BN_ZERO,
  BlueprintPromise,
  CodePromise,
  ContractPromise,
  DEFAULT,
  NOOP,
  WsProvider,
  call,
  chainDecimals,
  chainTokenSymbol,
  decodeError,
  encodeSalt,
  formatExtrinsicFailed,
  getBalance,
  getExpiredItem,
  getTimestampQuery,
  getTimestampUnix,
  getWalletBySource,
  getWallets,
  isContractInstantiatedEvent,
  isInBlock,
  isTxCancelledError,
  isValidHash,
  jsonToAbi,
  pseudoRandomHex,
  pseudoRandomId,
  toBasicMetadata,
  toContractAbiMessage,
  toContractOptions,
  toDeployOptions,
  toMessageParams,
  transfer,
  txPaymentInfo,
  unixMilliToDate
} from "./chunk-K4CFJTMJ.mjs";
import "./chunk-UT43TYHK.mjs";

// src/react/providers/config/model.ts
var DEFAULT_CONFIG = {
  dappName: "A dapp built with useInk!",
  chains: [RococoContractsTestnet],
  events: {
    expiration: FIVE_SECONDS,
    checkInterval: HALF_A_SECOND
  },
  setChainRpc: () => null,
  chainRpcs: {}
};

// src/react/providers/config/context.ts
import React from "react";
var ConfigContext = React.createContext(
  DEFAULT_CONFIG
);

// src/react/hooks/config/useConfig.ts
import { useContext } from "react";
var useConfig = () => useContext(ConfigContext);

// src/react/hooks/config/useChain.ts
import { useMemo } from "react";
var useChain = (chainId) => {
  const { chains } = useConfig();
  return useMemo(() => {
    return chainId ? chains.find((c) => c.id === chainId) : chains[0];
  }, [chains, chainId]);
};

// src/react/hooks/config/useChainRpc.ts
var useChainRpc = (chainId) => {
  const { chainRpcs } = useConfig();
  const chain = useChain(chainId);
  const chainIdOrDefault = chainId || chain?.id;
  return chainIdOrDefault && chainRpcs[chainIdOrDefault];
};

// src/react/hooks/config/useChainRpcList.ts
var useChainRpcList = (chainId) => {
  const chain = useChain(chainId);
  const { setChainRpc } = useConfig();
  return { rpcs: chain?.rpcs || [], setChainRpc };
};

// src/react/hooks/config/useChains.ts
var useChains = () => useConfig().chains;

// src/react/hooks/config/useDefaultCaller.ts
import { useMemo as useMemo2 } from "react";
var useDefaultCaller = (chainId) => {
  const { caller } = useConfig();
  const defaultChain = useChain();
  if (!caller)
    return;
  return useMemo2(
    () => caller[`${chainId || defaultChain}`] || caller.default,
    [chainId, caller, defaultChain]
  );
};

// src/react/hooks/contracts/useAbiMessage.ts
import { useMemo as useMemo3 } from "react";
function useAbiMessage(contract, message) {
  const abiMessage = useMemo3(() => {
    if (!contract)
      return;
    return toContractAbiMessage(contract, message);
  }, [contract, message]);
  if (!abiMessage || !abiMessage.ok)
    return;
  return abiMessage.value;
}

// src/react/providers/wallet/model.ts
var WALLET_DEFAULTS = {
  connect: () => void 0,
  disconnect: () => void 0,
  account: void 0,
  accounts: void 0,
  setAccount: () => void 0,
  isConnected: false,
  getWallets,
  getWalletBySource
};

// src/react/providers/wallet/context.ts
import { createContext } from "react";
var WalletContext = createContext({
  ...WALLET_DEFAULTS
});

// src/react/providers/wallet/provider.tsx
import React2, { useCallback, useEffect, useMemo as useMemo4, useState } from "react";
function getAutoConnectWalletInfo(key) {
  const item = localStorage.getItem(key);
  return item ? JSON.parse(item) : null;
}
function enableAutoConnect(a, key) {
  localStorage.setItem(key, JSON.stringify(a));
}
function disableAutoConnect(key) {
  if (getAutoConnectWalletInfo(key))
    localStorage.removeItem(key);
}
var WalletProvider = ({
  children
}) => {
  const C = useConfig();
  const [account, setWalletAccount] = useState();
  const [accounts, setAccounts] = useState();
  const [walletError, setWalletError] = useState();
  const dappName = useMemo4(
    () => C.dappName && C.dappName.trim().length > 0 ? C.dappName : "A Dapp built in useink",
    [C.dappName]
  );
  const [activeWallet, setActiveWallet] = useState();
  const disconnect = useCallback(() => {
    disableAutoConnect(dappName);
    setAccounts(void 0);
    setWalletAccount(void 0);
    setActiveWallet(void 0);
    setWalletError(void 0);
  }, [dappName]);
  const setAccount = useCallback(
    (newAccount) => {
      const accountDisabled = !accounts?.find(
        (a) => a.address === newAccount.address
      );
      if (accountDisabled) {
        setWalletError("AccountNotEnabled" /* AccountDisabled */);
        return;
      }
      walletError !== void 0 && setWalletError(void 0);
      setWalletAccount(newAccount);
      if (!C.wallet?.skipAutoConnect) {
        enableAutoConnect(
          {
            address: newAccount.address,
            wallet: newAccount.source
          },
          dappName
        );
      }
    },
    [accounts, C.wallet?.skipAutoConnect]
  );
  const connectWallet = useCallback(
    async (walletName) => {
      walletError && setWalletError(void 0);
      const w = getWalletBySource(walletName);
      if (!w) {
        setWalletError("WalletNotInstalled" /* WalletNotInstalled */);
        setActiveWallet(void 0);
        return;
      }
      try {
        await w.enable(dappName);
      } catch (_e) {
        setWalletError("EnableFailed" /* EnableFailed */);
        setActiveWallet(void 0);
        return;
      }
      const unsub = await w.subscribeAccounts((accts) => {
        setAccounts(accts);
        const firstAccount = accts?.[0];
        const noAccountsEnabled = !accts || !firstAccount;
        if (noAccountsEnabled) {
          setWalletError("NoAccountsEnabled" /* NoAccountsEnabled */);
          setWalletAccount(void 0);
          disableAutoConnect(dappName);
          return;
        }
        const activeAccountNoLongerConnected = account && !accts?.find((a) => a.address === account?.address);
        if (activeAccountNoLongerConnected) {
          setWalletAccount(firstAccount);
          if (!C.wallet?.skipAutoConnect) {
            enableAutoConnect(
              {
                address: firstAccount.address,
                wallet: firstAccount.source
              },
              dappName
            );
          }
          return;
        }
        const autoConnect = getAutoConnectWalletInfo(dappName);
        const autoConnectAccount = autoConnect && accts.find((a) => a.address === autoConnect.address);
        const initialAccount = autoConnectAccount || firstAccount;
        setWalletAccount(initialAccount);
        if (!C.wallet?.skipAutoConnect) {
          enableAutoConnect(
            {
              address: initialAccount.address,
              wallet: initialAccount.source
            },
            dappName
          );
        }
      });
      return unsub;
    },
    []
  );
  const connect = useCallback((walletName) => {
    setActiveWallet(walletName);
  }, []);
  useEffect(() => {
    if (!activeWallet) {
      const wallet = getAutoConnectWalletInfo(dappName)?.wallet;
      if (wallet)
        setActiveWallet(wallet);
      return;
    }
    let unsubFunc;
    connectWallet(activeWallet).then((unsub) => unsubFunc === unsub);
    return () => unsubFunc?.();
  }, [activeWallet]);
  return /* @__PURE__ */ React2.createElement(
    WalletContext.Provider,
    {
      value: {
        account,
        isConnected: Boolean(account),
        accounts,
        connect,
        disconnect,
        walletError,
        setAccount,
        getWallets,
        getWalletBySource
      }
    },
    children
  );
};

// src/react/hooks/wallets/useWallet.ts
import { useContext as useContext2 } from "react";
var useWallet = () => useContext2(WalletContext);

// src/react/hooks/contracts/useCall.ts
import { useCallback as useCallback2, useState as useState2 } from "react";
var CallError = /* @__PURE__ */ ((CallError2) => {
  CallError2["ContractUndefined"] = "Contract is undefined";
  CallError2["InvalidAbiMessage"] = "Invalid ABI Message";
  CallError2["NoResponse"] = "No response";
  return CallError2;
})(CallError || {});
function useCall(chainContract, message) {
  const [result, setResult] = useState2();
  const [isSubmitting, setIsSubmitting] = useState2(false);
  const abiMessage = useAbiMessage(chainContract?.contract, message);
  const { account } = useWallet();
  const defaultCaller = useDefaultCaller(chainContract?.chainId);
  const send = useCallback2(
    async (args, options) => {
      const caller = account?.address ? account.address : options?.defaultCaller ? defaultCaller : void 0;
      if (!abiMessage || !chainContract?.contract || !caller)
        return;
      try {
        setIsSubmitting(true);
        const callResult = await call(
          chainContract.contract,
          abiMessage,
          caller,
          args,
          options
        );
        setResult(callResult);
        setIsSubmitting(false);
        return callResult;
      } catch (e) {
        console.error(e);
        setIsSubmitting(false);
        return;
      }
    },
    [account, abiMessage]
  );
  return { send, isSubmitting, result };
}

// src/react/providers/blockHeader/model.ts
var BLOCK_HEADER_DEFAULTS = {};

// src/react/providers/blockHeader/context.ts
import { createContext as createContext2 } from "react";
var BlockHeaderContext = createContext2({
  ...BLOCK_HEADER_DEFAULTS
});

// src/react/providers/blockHeader/reducer.ts
function chainBlockHeaderReducer(state, action) {
  switch (action.type) {
    case "ADD_CHAIN_BLOCK_HEADER":
      return {
        ...state,
        [action.chainId]: action.blockHeader
      };
  }
}

// src/react/providers/blockHeader/provider.tsx
import React3, { useEffect as useEffect2, useMemo as useMemo5, useReducer } from "react";
var toBlockNumber = (valWithComma) => parseInt(`${valWithComma?.split(",").join("")}`);
var BlockHeaderProvider = ({
  children
}) => {
  const chainApis = useApis();
  const [chainBlockHeaders, dispatch] = useReducer(
    chainBlockHeaderReducer,
    {}
  );
  const chainIds = useMemo5(
    () => chainApis.apis ? Object.keys(chainApis.apis) : [],
    [chainApis]
  );
  useEffect2(() => {
    function listenToBlocks() {
      return chainIds.map((chainId) => {
        return chainApis?.apis?.[chainId]?.api?.rpc.chain.subscribeNewHeads(
          (header) => {
            try {
              const blockNumber = toBlockNumber(
                header.number.toHuman()?.toString()
              );
              blockNumber && dispatch({
                type: "ADD_CHAIN_BLOCK_HEADER",
                chainId,
                blockHeader: { blockNumber, header }
              });
            } catch (e) {
              console.error(e);
            }
          }
        );
      });
    }
    let unsubFuncs;
    Promise.all(listenToBlocks()).then((unsubs) => unsubFuncs === unsubs);
    return () => {
      unsubFuncs?.forEach((unsub) => unsub?.());
    };
  }, [chainApis]);
  return /* @__PURE__ */ React3.createElement(BlockHeaderContext.Provider, { value: chainBlockHeaders }, children);
};

// src/react/hooks/substrate/useBlockHeader.ts
import { useContext as useContext3 } from "react";
var useBlockHeader = (chainId) => {
  const chain = useChain(chainId);
  return chain ? useContext3(BlockHeaderContext)[chain.id] : void 0;
};
var useBlockHeaders = () => useContext3(BlockHeaderContext);

// src/react/hooks/contracts/useCallSubscription.ts
import { useEffect as useEffect3 } from "react";
function useCallSubscription(chainContract, message, args = [], options) {
  const call2 = useCall(chainContract, message);
  const blockNumber = useBlockHeader(chainContract?.chainId)?.blockNumber;
  useEffect3(() => {
    call2.send(args, options);
  }, [blockNumber]);
  return call2;
}

// src/react/hooks/contracts/useCodeHash.ts
import { useCallback as useCallback3, useEffect as useEffect4, useState as useState3 } from "react";
var CodeHashError = /* @__PURE__ */ ((CodeHashError2) => {
  CodeHashError2["InvalidHash"] = "Invalid code hash value.";
  return CodeHashError2;
})(CodeHashError || {});
var useCodeHash = () => {
  const [codeHash, setCodeHash] = useState3("");
  const [error, setError] = useState3();
  useEffect4(() => {
    if (isValidHash(codeHash, 64)) {
      error && setError(void 0);
      return;
    }
    codeHash && setError("Invalid code hash value." /* InvalidHash */);
  }, [codeHash]);
  const set = useCallback3((s) => {
    setCodeHash(s || "");
  }, []);
  const resetState = useCallback3(() => {
    setCodeHash("");
    setError(void 0);
  }, []);
  return {
    codeHash,
    resetState,
    set,
    error
  };
};

// src/react/providers/api/context.ts
import { createContext as createContext3 } from "react";
var APIContext = createContext3({
  apis: {}
});

// src/react/providers/api/reducer.ts
function apiProvidersReducer(state, action) {
  switch (action.type) {
    case "ADD_API_PROVIDER":
      return {
        ...state,
        [action.chainId]: action.apiProvider
      };
  }
}

// src/react/providers/api/provider.tsx
import React4, { useEffect as useEffect5, useReducer as useReducer2 } from "react";
var APIProvider = ({
  children
}) => {
  const chains = useChains();
  const { chainRpcs } = useConfig();
  const [apis, dispatch] = useReducer2(apiProvidersReducer, {});
  useEffect5(() => {
    chains.forEach((chain) => {
      const provider = new WsProvider(chainRpcs[chain.id] || chain.rpcs[0]);
      ApiPromise.create({ provider }).then((api) => {
        dispatch({
          type: "ADD_API_PROVIDER",
          chainId: chain.id,
          apiProvider: { api, provider }
        });
      });
    });
  }, [chains, chainRpcs]);
  return /* @__PURE__ */ React4.createElement(APIContext.Provider, { value: { apis } }, children);
};

// src/react/hooks/substrate/useApi.ts
import { useContext as useContext4 } from "react";
var useApis = () => useContext4(APIContext);
var useApi = (chainId) => {
  const defaultChain = useChain();
  const idOrDefault = chainId || defaultChain?.id;
  return idOrDefault ? useApis()?.apis?.[idOrDefault] : void 0;
};

// src/react/hooks/contracts/useContract.ts
import { useEffect as useEffect6, useMemo as useMemo6, useState as useState4 } from "react";
function useContract(address, metadata, chainId) {
  const [contract, setContract] = useState4();
  const chainConfig = useChain(chainId);
  const { api } = useApi(chainConfig?.id) || {};
  const abi = useMemo6(
    () => api && new Abi(metadata, api.registry.getChainProperties()),
    [api]
  );
  useEffect6(() => {
    try {
      api && abi && setContract(new ContractPromise(api, abi, address));
    } catch (err) {
      console.error("Couldn't create contract instance: ", err);
    }
  }, [abi, address, api]);
  return chainConfig && contract ? { chainId: chainConfig.id, contract } : void 0;
}

// src/react/hooks/contracts/useTxEvents.ts
import { useCallback as useCallback4, useEffect as useEffect7, useState as useState5 } from "react";
var useTxEvents = (tx) => {
  const [events, setEvents] = useState5([]);
  const resetState = useCallback4(() => setEvents([]), []);
  useEffect7(() => {
    if (!isInBlock(tx) || !tx.result)
      return;
    setEvents([...tx.result.events]);
  }, [tx.status]);
  return { events, resetState };
};

// src/react/hooks/contracts/useDeployer/types.ts
var DeployerError = /* @__PURE__ */ ((DeployerError2) => {
  DeployerError2["NoCodeHashOrWasm"] = "You must supply either a code hash or metadata containing Wasm.";
  DeployerError2["ConstructorNotFound"] = "The constructor method was not found.";
  DeployerError2["InstantiateNotSupportedForApi"] = "Instantiate method not found for chain API";
  DeployerError2["CouldNotCreateTx"] = "Could not create deploy transaction function";
  DeployerError2["TransactionFailed"] = "Transaction failed.";
  DeployerError2["TransactionCancelled"] = "Transaction cancelled.";
  DeployerError2["WalletNotConnected"] = "Wallet not connected.";
  DeployerError2["ApiInstanceNotFound"] = "Api client not found. Try refreshing the page.";
  DeployerError2["InvalidCodeHash"] = "Invalid code hash.";
  return DeployerError2;
})(DeployerError || {});

// src/react/hooks/contracts/useDeployer/useDeployer.ts
import { useCallback as useCallback5, useEffect as useEffect8, useMemo as useMemo7, useState as useState6 } from "react";
function useDeployer(chainId) {
  const { account } = useWallet();
  const chainApi = useApi(chainId);
  const chain = useChain(chainId);
  const C = useConfig();
  const [isSubmitting, setIsSubmitting] = useState6(false);
  const [willBeSuccessful, setWillBeSuccessful] = useState6(false);
  const [status, setStatus] = useState6("None");
  const [result, setResult] = useState6();
  const [contractAddress, setContractAddress] = useState6();
  const [error, setError] = useState6();
  const [gasConsumed, setGasConsumed] = useState6();
  const [gasRequired, setGasRequired] = useState6();
  const [storageDeposit, setStorageDeposit] = useState6();
  const txEvents = useTxEvents({ status, result });
  useEffect8(() => {
    txEvents.events.forEach((event) => {
      const failure = formatExtrinsicFailed(event, chainApi?.api);
      failure && setError(failure);
    });
  }, [txEvents]);
  const wasDeployed = useMemo7(
    () => Boolean(txEvents.events.find(isContractInstantiatedEvent)),
    [txEvents.events]
  );
  const resetState = useCallback5(() => {
    setResult(void 0);
    setError(void 0);
    setContractAddress(void 0);
    setStatus("None");
    setIsSubmitting(false);
    setGasConsumed(void 0);
    setGasRequired(void 0);
    setStorageDeposit(void 0);
    txEvents.resetState();
  }, []);
  const dryRun = useMemo7(
    () => async (abi, constructorName, constructorParams, options, cb = NOOP) => {
      if (!chainApi?.api) {
        setError("Api client not found. Try refreshing the page." /* ApiInstanceNotFound */);
        return;
      }
      setError(void 0);
      const constructorMessage = constructorName ? abi.constructors.find(({ method }) => method === constructorName) : abi.constructors?.[0];
      if (!constructorMessage) {
        setError("The constructor method was not found." /* ConstructorNotFound */);
        return;
      }
      const { codeHash } = toDeployOptions(options);
      const wasm = abi.info.source.wasm;
      const hasCodeHashOrWasm = codeHash !== void 0 || !!wasm;
      if (!hasCodeHashOrWasm) {
        setError("You must supply either a code hash or metadata containing Wasm." /* NoCodeHashOrWasm */);
        return;
      }
      if (codeHash !== void 0 && !isValidHash(codeHash, 64)) {
        setError("Invalid code hash." /* InvalidCodeHash */);
        return;
      }
      const code = codeHash ? new BlueprintPromise(chainApi.api, abi, codeHash) : new CodePromise(chainApi.api, abi, wasm.toU8a());
      const abiParams = constructorMessage.args;
      if (!chainApi?.api?.call?.contractsApi?.instantiate) {
        setError("Instantiate method not found for chain API" /* InstantiateNotSupportedForApi */);
        return;
      }
      const messageParams = constructorMessage.toU8a(
        toMessageParams(chainApi.api, abiParams, constructorParams || {})
      );
      const caller = account?.address || (chain?.id ? C?.caller?.[chain?.id] : C.caller?.default);
      const gasLimitMax = null;
      const storageDepositMax = null;
      const payableValue = chainApi.api.registry.createType(
        "Balance",
        toDeployOptions(options).value
      );
      const params = [
        caller,
        payableValue,
        gasLimitMax,
        storageDepositMax,
        codeHash ? { Existing: codeHash } : { Upload: abi.info.source.wasm },
        messageParams,
        options?.salt ? encodeSalt(options?.salt) : ""
      ];
      setIsSubmitting(true);
      let res;
      try {
        res = await chainApi.api.call.contractsApi.instantiate(...params);
        setIsSubmitting(false);
      } catch (e) {
        setError(e?.toString());
        setIsSubmitting(false);
        return;
      }
      setWillBeSuccessful(res.result.isOk);
      if (res.result.isOk) {
        setContractAddress(res.result.asOk.accountId.toString());
      } else {
        setError(
          decodeError(res.result.asErr, { contract: { api: chainApi.api } })
        );
        return;
      }
      setGasConsumed(res.gasConsumed);
      setGasRequired(res.gasRequired);
      setStorageDeposit(res.storageDeposit);
      let tx;
      try {
        const method = code.tx[constructorMessage.method];
        const methodOptions = {
          gasLimit: res.gasRequired,
          storageDepositLimit: res.storageDeposit.asCharge || null,
          ...toDeployOptions(options)
        };
        tx = constructorMessage.args.length > 0 ? method?.(methodOptions, ...messageParams) : method?.(methodOptions);
      } catch (e) {
        setError(e?.toString());
        return;
      }
      if (!tx) {
        cb?.(void 0, chainApi.api, "Could not create deploy transaction function" /* CouldNotCreateTx */);
        setError("Could not create deploy transaction function" /* CouldNotCreateTx */);
        return;
      }
      return tx;
    },
    [account, chainApi?.api]
  );
  const signAndSend = useMemo7(
    () => async (abi, constructorName, constructorArgs = {}, options = { value: BN_ZERO }, cb = NOOP) => {
      if (!account || !account?.wallet?.extension.signer) {
        setError("Wallet not connected." /* WalletNotConnected */);
        return;
      }
      if (!chainApi?.api) {
        setError("Api client not found. Try refreshing the page." /* ApiInstanceNotFound */);
        return;
      }
      txEvents.resetState();
      dryRun(abi, constructorName, constructorArgs, options, cb).then(
        (tx) => {
          tx && setStatus("PendingSignature");
          tx?.signAndSend(
            account?.address,
            { signer: account?.wallet?.extension.signer },
            (response) => {
              if (response.status.isInBlock) {
                setContractAddress(response?.contract?.address.toString());
              }
              if (response.isError) {
                const err = decodeError(response.dispatchError, {
                  contract: { api: chainApi.api }
                });
                setError(err);
              }
              setStatus(response.status.type);
              setResult(response);
              cb?.(response, chainApi.api);
            }
          ).catch((e) => {
            cb?.(void 0, chainApi.api, e);
            setStatus("None");
            if (isTxCancelledError(e)) {
              setError("Transaction cancelled." /* TransactionCancelled */);
              return;
            }
            setError("Transaction failed." /* TransactionFailed */);
          }).finally(() => {
            setIsSubmitting(false);
          });
        }
      );
    },
    [account, account?.wallet?.extension?.signer, chainApi?.api]
  );
  return {
    dryRun,
    signAndSend,
    contractAddress,
    status,
    result,
    isSubmitting,
    error,
    resetState,
    willBeSuccessful,
    wasDeployed,
    storageDeposit,
    gasConsumed,
    gasRequired,
    events: txEvents.events
  };
}

// src/react/hooks/contracts/useDryRun.ts
import { useMemo as useMemo8, useState as useState7 } from "react";
function useDryRun(chainContract, message) {
  const { account } = useWallet();
  const defaultCaller = useDefaultCaller(chainContract?.chainId);
  const [result, setResult] = useState7();
  const [isSubmitting, setIsSubmitting] = useState7(false);
  const abiMessage = useAbiMessage(chainContract?.contract, message);
  const send = useMemo8(
    () => async (params, options) => {
      const tx = chainContract?.contract?.tx?.[message];
      const caller = account?.address ? account.address : options?.defaultCaller ? defaultCaller : void 0;
      if (!caller || !chainContract?.contract || !abiMessage || !tx) {
        return;
      }
      setIsSubmitting(true);
      try {
        const resp = await call(
          chainContract.contract,
          abiMessage,
          caller,
          params,
          options
        );
        if (!resp || !resp.ok)
          return;
        const { gasConsumed, gasRequired, storageDeposit } = resp.value.raw;
        const requiresNoArguments = tx.meta.args.length === 0;
        const { partialFee } = await (requiresNoArguments ? tx(toContractOptions(options)) : tx(toContractOptions(options), ...params || [])).paymentInfo(caller);
        const r = {
          ...resp,
          value: {
            ...resp.value,
            gasRequired,
            gasConsumed,
            storageDeposit,
            partialFee
          }
        };
        setIsSubmitting(false);
        setResult(r);
        return r;
      } catch (e) {
        console.error(e);
        setIsSubmitting(false);
        return;
      }
    },
    [account, chainContract?.contract, abiMessage]
  );
  return {
    send,
    isSubmitting,
    result,
    resolved: Boolean(result && !isSubmitting),
    resetState: () => {
      setIsSubmitting(false);
      setResult(void 0);
    }
  };
}

// src/react/providers/events/model.ts
var DEFAULT_EVENTS = {};

// src/react/providers/events/context.ts
import { createContext as createContext4 } from "react";
var EventsContext = createContext4({
  events: DEFAULT_EVENTS,
  addEvent: () => null,
  removeEvent: () => null
});

// src/react/providers/events/reducer.ts
function eventsReducer(state, action) {
  switch (action.type) {
    case "ADD_EVENT":
      return {
        ...state,
        [action.address]: [...state[action.address] || [], action.event]
      };
    case "REMOVE_EVENT": {
      const events = state[action.address];
      if (!events)
        return state;
      const idx = events.findIndex((e) => e.id === action.eventId);
      if (idx < 0)
        return state;
      const newContractState = [
        ...events.slice(0, idx),
        ...events.slice(idx + 1, events.length)
      ];
      return {
        ...state,
        [action.address]: newContractState
      };
    }
  }
}

// src/react/providers/events/provider.tsx
import React5 from "react";
var EventsProvider = ({
  children
}) => {
  const [events, dispatch] = React5.useReducer(eventsReducer, DEFAULT_EVENTS);
  const isMounted = useIsMounted();
  const addEvent = React5.useCallback(
    ({ event, address }) => {
      if (isMounted()) {
        dispatch({
          type: "ADD_EVENT",
          address,
          event: { ...event, id: pseudoRandomId(), createdAt: Date.now() }
        });
      }
    },
    [dispatch]
  );
  const removeEvent = React5.useCallback(
    ({ eventId, address }) => {
      if (isMounted()) {
        dispatch({
          type: "REMOVE_EVENT",
          address,
          eventId
        });
      }
    },
    [dispatch]
  );
  return /* @__PURE__ */ React5.createElement(
    EventsContext.Provider,
    {
      value: { addEvent, events, removeEvent },
      children
    }
  );
};

// src/react/hooks/contracts/useEventSubscription.ts
import { useContext as useContext5, useEffect as useEffect9 } from "react";
var useEventSubscription = (chainContract) => {
  const { events, addEvent, removeEvent } = useContext5(EventsContext);
  const { blockNumber, header } = useBlockHeader(chainContract?.chainId) || {};
  const C = useConfig();
  const address = chainContract?.contract?.address?.toString() || "";
  const contractEvents = events?.[address] || [];
  useEffect9(() => {
    const contract = chainContract?.contract;
    if (!header?.hash || !contract)
      return;
    contract.api.at(header?.hash).then((apiAt) => {
      apiAt.query.system?.events?.((encodedEvent) => {
        encodedEvent.forEach(({ event }) => {
          if (contract.api.events.contracts?.ContractEmitted?.is(event)) {
            const [contractAddress, contractEvent] = event.data;
            if (!address || !contractAddress || !contractEvent || contractAddress.toString().toLowerCase() !== address.toLowerCase())
              return;
            try {
              const decodedEvent = contract.abi.decodeEvent(
                contractEvent
              );
              const eventItem = {
                address,
                event: {
                  name: decodedEvent.event.identifier,
                  args: decodedEvent.args.map((v) => v.toHuman())
                }
              };
              addEvent(eventItem);
            } catch (e) {
              console.error(e);
            }
          }
        });
      });
    });
  }, [chainContract?.contract, blockNumber]);
  useInterval(() => {
    if (C.events?.expiration === 0)
      return;
    const expiredEvents = getExpiredItem(
      contractEvents,
      C.events?.expiration || FIVE_SECONDS
    );
    for (const event of expiredEvents) {
      removeEvent({ eventId: event.id, address });
    }
  }, C.events?.checkInterval || HALF_A_SECOND);
};

// src/react/hooks/contracts/useEvents.ts
import { useContext as useContext6, useMemo as useMemo9 } from "react";
var useEvents = (contractAddress, filters) => {
  const { events, removeEvent } = useContext6(EventsContext);
  const contractEvents = useMemo9(() => {
    if (!contractAddress)
      return [];
    return events[contractAddress.toString()]?.filter(
      ({ name }) => filters ? filters.includes(name) : true
    ) ?? [];
  }, [events, contractAddress]);
  return { events: contractEvents, removeEvent };
};

// src/react/hooks/contracts/useMetadata.ts
import { useEffect as useEffect10, useState as useState8 } from "react";
var utf8decoder = new TextDecoder();
var formatName = (n) => n.replace(".contract", "").replace(".json", "").split("_").join(" ");
function useMetadata(options = { requireWasm: true }, initialValue, chainId) {
  const chainApi = useApi(chainId);
  const { requireWasm } = options;
  const [state, setState] = useState8(
    () => jsonToAbi({ ...options }, initialValue, chainApi?.api)
  );
  function set(file) {
    toBasicMetadata(file).then((basicFile) => {
      const json = JSON.parse(utf8decoder.decode(basicFile.data));
      const newState = jsonToAbi(
        {
          requireWasm,
          name: formatName(basicFile.name),
          size: basicFile.size
        },
        json,
        chainApi?.api
      );
      if (newState.error) {
        setState({
          ...DEFAULT,
          error: newState.error
        });
        return;
      }
      setState(newState);
    }).catch((_) => {
      setState({
        ...DEFAULT,
        error: "Invalid file." /* InvalidFile */
      });
    });
  }
  function clear() {
    setState(DEFAULT);
  }
  useEffect10(() => {
    setState(
      jsonToAbi({ requireWasm }, initialValue, chainApi?.api)
    );
  }, [chainApi?.api, initialValue, requireWasm]);
  return {
    ...state,
    set,
    clear
  };
}

// src/react/hooks/contracts/useSalter.ts
import { useCallback as useCallback6, useEffect as useEffect11, useState as useState9 } from "react";
var SalterError = /* @__PURE__ */ ((SalterError2) => {
  SalterError2["InvalidHash"] = "Invalid salt hash value.";
  return SalterError2;
})(SalterError || {});
var useSalter = () => {
  const [salt, setSalt] = useState9(pseudoRandomHex());
  const [error, setError] = useState9();
  useEffect11(() => {
    if (isValidHash(salt)) {
      error && setError(void 0);
      return;
    }
    setError("Invalid salt hash value." /* InvalidHash */);
  }, [salt]);
  const regenerate = useCallback6(() => {
    const s = pseudoRandomHex();
    setSalt(s);
  }, []);
  const set = useCallback6((s) => {
    setSalt(s);
  }, []);
  const resetState = useCallback6(() => {
    setSalt("");
    setError(void 0);
  }, []);
  return {
    salt,
    resetState,
    regenerate,
    set,
    error
  };
};

// src/react/hooks/contracts/useTx.ts
import { useMemo as useMemo10, useState as useState10 } from "react";
function useTx(chainContract, message) {
  const { account } = useWallet();
  const [status, setStatus] = useState10("None");
  const [result, setResult] = useState10();
  const dryRun = useDryRun(chainContract, message);
  const txEvents = useTxEvents({ status, result });
  const signAndSend = useMemo10(
    () => (params, options, cb) => {
      if (!chainContract?.contract || !account || !account.wallet?.extension) {
        return;
      }
      dryRun.send(params, options).then((response) => {
        if (!response || !response.ok)
          return;
        setStatus("PendingSignature");
        const { gasRequired } = response.value.raw;
        const tx = chainContract?.contract.tx[message];
        if (!tx) {
          cb?.(
            void 0,
            chainContract.contract.api,
            `'${message}' not found on contract instance`
          );
          return;
        }
        tx(
          { gasLimit: gasRequired, ...toContractOptions(options) },
          ...params || []
        ).signAndSend(
          account.address,
          { signer: account.wallet?.extension?.signer },
          (response2) => {
            setResult(response2);
            setStatus(response2.status.type);
            cb?.(response2, chainContract?.contract.api);
          }
        ).catch((e) => {
          cb?.(void 0, chainContract.contract.api, e);
          setStatus("None");
        });
      }).catch((e) => {
        cb?.(void 0, chainContract.contract.api, e);
        setStatus("None");
      });
    },
    [account, account?.wallet?.extension?.signer, chainContract?.contract]
  );
  return {
    signAndSend,
    status,
    result,
    resetState: () => {
      setResult(void 0);
      setStatus("None");
      txEvents.resetState();
    },
    events: txEvents.events
  };
}

// src/react/hooks/contracts/useTxPaymentInfo.ts
import { useCallback as useCallback7, useState as useState11 } from "react";
function useTxPaymentInfo(chainContract, message) {
  const [isSubmitting, setIsSubmitting] = useState11(false);
  const [result, setResult] = useState11();
  const { account } = useWallet();
  const defaultCaller = useDefaultCaller();
  const send = useCallback7(
    async (params, options, signerOptions) => {
      const caller = account?.address || options?.defaultCaller ? defaultCaller : void 0;
      if (!chainContract?.contract || !caller)
        return;
      try {
        setIsSubmitting(true);
        const paymentInfoResult = await txPaymentInfo(
          chainContract.contract,
          message,
          caller,
          params,
          options,
          signerOptions
        );
        setResult(paymentInfoResult);
        setIsSubmitting(false);
        return paymentInfoResult;
      } catch (e) {
        console.error(e);
        setIsSubmitting(false);
        return;
      }
    },
    [chainContract?.contract, message, account, defaultCaller]
  );
  return {
    isSubmitting,
    resolved: Boolean(!isSubmitting && result),
    result,
    send
  };
}

// src/react/hooks/helpers/useUnixMilliToDate.ts
import { useMemo as useMemo11 } from "react";
var useUnixMilliToDate = (unixInMilliSeconds) => useMemo11(() => unixMilliToDate(unixInMilliSeconds), [unixInMilliSeconds]);

// src/react/hooks/substrate/balance/useBalance.ts
import { useEffect as useEffect12, useState as useState12 } from "react";
var useBalance = (account, chainId) => {
  const [balance, setBalance] = useState12();
  const { blockNumber } = useBlockHeader(chainId) || {};
  const chainConfig = useChain(chainId);
  const chain = useApi(chainConfig?.id);
  useEffect12(() => {
    if (!chain?.api || !account || !account.address)
      return;
    getBalance(chain.api, account).then(setBalance).catch(console.error);
  }, [blockNumber, account]);
  return balance;
};

// src/react/hooks/substrate/timestamp/useTimestampNow.ts
import { useEffect as useEffect13, useState as useState13 } from "react";
var useTimestampNow = (chainId) => {
  const [now, setNow] = useState13();
  const b = useBlockHeader(chainId);
  const chainApi = useApi(chainId);
  useEffect13(() => {
    getTimestampUnix(chainApi?.api).then(setNow).catch();
  }, [b?.blockNumber]);
  return now;
};

// src/react/hooks/substrate/timestamp/useTimestampDate.ts
var useTimestampDate = (chainId) => {
  const unix = useTimestampNow(chainId);
  return useUnixMilliToDate(unix);
};

// src/react/hooks/substrate/timestamp/useTimestampQuery.ts
import { useEffect as useEffect14, useState as useState14 } from "react";
var useTimestampQuery = (chainId) => {
  const chainApi = useApi(chainId);
  const [timestamp, setTimestamp] = useState14();
  useEffect14(() => {
    const t = getTimestampQuery(chainApi?.api);
    setTimestamp(t);
  }, [chainApi?.api]);
  return timestamp;
};

// src/react/hooks/substrate/useChainDecimals.ts
var useChainDecimals = (chainId) => {
  const chainApi = useApi(chainId);
  if (!chainApi?.api)
    return void 0;
  return chainDecimals(chainApi?.api);
};

// src/react/hooks/substrate/useTokenSymbol.ts
var useTokenSymbol = (chainId) => {
  const chainApi = useApi(chainId);
  if (!chainApi?.api)
    return void 0;
  return chainTokenSymbol(chainApi?.api);
};

// src/react/hooks/substrate/useTransfer.ts
import { useCallback as useCallback8, useMemo as useMemo12, useState as useState15 } from "react";
var useTransfer = (chainId) => {
  const [hash, setHash] = useState15();
  const [error, setError] = useState15();
  const [isSubmitting, setIsSubmitting] = useState15(false);
  const { account } = useWallet();
  const chainConfig = useChain(chainId);
  const chain = useApi(chainConfig?.id);
  const resetState = useCallback8(() => {
    setHash(void 0);
    setError(void 0);
  }, []);
  const signAndSend = useMemo12(
    () => (to, amount, options) => {
      if (!chain?.api || !account || !account.address || !account.wallet) {
        return;
      }
      setIsSubmitting(true);
      transfer(chain.api, to, amount, account?.wallet.extension.signer, options).then(setHash).catch(setError).finally(() => setIsSubmitting(false));
    },
    [chain?.api, account?.address]
  );
  return { signAndSend, error, hash, resetState, isSubmitting };
};

// src/react/hooks/wallets/useAllWallets.ts
import { useMemo as useMemo13 } from "react";
var useAllWallets = () => {
  const { getWallets: getWallets2 } = useWallet();
  return useMemo13(() => getWallets2(), []);
};

// src/react/hooks/wallets/useInstalledWallets.ts
import { useMemo as useMemo14 } from "react";
var useInstalledWallets = () => {
  const { getWallets: getWallets2 } = useWallet();
  return useMemo14(() => getWallets2().filter((w) => w.installed), []);
};

// src/react/hooks/wallets/useUninstalledWallets.ts
import { useMemo as useMemo15 } from "react";
var useUninstalledWallets = () => {
  const { getWallets: getWallets2 } = useWallet();
  return useMemo15(() => getWallets2().filter((w) => !w.installed), []);
};

// src/react/providers/config/provider.tsx
import React6, { useCallback as useCallback9, useEffect as useEffect15, useMemo as useMemo16, useState as useState16 } from "react";
var toInitialRpcs = (c, _rpcs) => c.reduce(
  (acc, ch) => ({ ...acc, [ch.id]: ch.rpcs?.[0] || "" }),
  {}
);
var ConfigProvider = ({
  config,
  children
}) => {
  const defaultChainId = useMemo16(() => config.chains[0].id, [config.chains[0]]);
  const [chainRpcs, setChainRpcs] = useState16(
    toInitialRpcs(config.chains, {})
  );
  const setChainRpc = useCallback9((rpc, cid) => {
    const chainIdOrDefault = cid || defaultChainId;
    chainIdOrDefault && setChainRpcs({ ...chainRpcs, [chainIdOrDefault]: rpc });
  }, []);
  useEffect15(() => {
    setChainRpcs(toInitialRpcs(config.chains, chainRpcs));
    if (!config.chains.length) {
      const error = "Chains not configured in Config Provider";
      console.error(error);
      throw Error(error);
    }
  }, [config.chains]);
  return /* @__PURE__ */ React6.createElement(
    ConfigContext.Provider,
    {
      value: {
        ...DEFAULT_CONFIG,
        ...config,
        setChainRpc,
        chainRpcs
      },
      children
    }
  );
};

// src/react/providers/UseInkProvider.tsx
import React7 from "react";
var UseInkProvider = ({
  children,
  config
}) => /* @__PURE__ */ React7.createElement(ConfigProvider, { config }, /* @__PURE__ */ React7.createElement(WalletProvider, null, /* @__PURE__ */ React7.createElement(APIProvider, null, /* @__PURE__ */ React7.createElement(BlockHeaderProvider, null, /* @__PURE__ */ React7.createElement(EventsProvider, null, children)))));
export {
  APIContext,
  APIProvider,
  CallError,
  CodeHashError,
  DeployerError,
  SalterError,
  UseInkProvider,
  useAbiMessage,
  useAllWallets,
  useApi,
  useApis,
  useBalance,
  useBlockHeader,
  useBlockHeaders,
  useCall,
  useCallSubscription,
  useChain,
  useChainDecimals,
  useChainRpc,
  useChainRpcList,
  useChains,
  useCodeHash,
  useConfig,
  useContract,
  useDefaultCaller,
  useDeployer,
  useDryRun,
  useEventSubscription,
  useEvents,
  useInstalledWallets,
  useMetadata,
  useSalter,
  useTimestampDate,
  useTimestampNow,
  useTimestampQuery,
  useTokenSymbol,
  useTransfer,
  useTx,
  useTxEvents,
  useTxPaymentInfo,
  useUninstalledWallets,
  useUnixMilliToDate,
  useWallet
};
