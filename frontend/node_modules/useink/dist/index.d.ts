import { ChainId, Chain } from './chains.js';
import { A as ArrayOneOrMore } from './array-a9317543.js';
import { C as ChainContract, a as ContractSubmittableResultCallback, T as Tx } from './useTx-805af648.js';
export { b as CallOptions, c as ContractAbi, S as SignAndSend, u as useTx } from './useTx-805af648.js';
import { ContractPromise, Abi } from '@polkadot/api-contract';
import { AbiMessage, BlueprintOptions } from '@polkadot/api-contract/types';
import { c as LazyCallOptions, D as DecodedContractResult, T as TransactionStatus, g as DecodedTxResult, W as WithAddress } from './contracts-5e7fdfd7.js';
import { C as ContractSubmittableResult } from './api-contract-c4a7a321.js';
import { BN } from '@polkadot/util';
import { Balance, WeightV2, StorageDeposit, EventRecord, AccountId, RuntimeDispatchInfo, Header, Hash } from '@polkadot/types/interfaces';
import { Bytes } from '@polkadot/types';
import { SubmittableExtrinsic, SignerOptions, QueryableModuleCalls } from '@polkadot/api/types';
import { ISubmittableResult } from '@polkadot/types/types';
export { B as BasicMetadataFile, U as UseMetadata, u as useMetadata } from './useMetadata-a5a897cb.js';
import { DeriveBalancesAccount } from '@polkadot/api-derive/types';
import { ApiPromise, WsProvider } from '@polkadot/api';
import { WalletAccount, getWallets, getWalletBySource } from '@talismn/connect-wallets';
import * as React from 'react';
import React__default from 'react';
import './jsonToAbi-312b7654.js';

declare const useChain: (chainId?: ChainId) => Chain | undefined;

declare const useChainRpc: (chainId?: ChainId) => string | undefined;

type ChainRPCs = Partial<Record<ChainId, string>>;
type CallerAddress = string;
type ConfigProps = {
    dappName?: string;
    chains: ArrayOneOrMore<Chain>;
    caller?: {
        default?: CallerAddress;
    } & Partial<Record<ChainId, CallerAddress>>;
    events?: {
        expiration?: number;
        checkInterval?: number;
    };
    wallet?: {
        skipAutoConnect?: boolean;
    };
};
type SetChainRpc = (rpc: string, chain?: ChainId) => void;
interface ChainConfig {
    setChainRpc: SetChainRpc;
    chainRpcs: ChainRPCs;
}
type Config = ChainConfig & ConfigProps;

interface RpcList {
    rpcs: readonly string[];
    setChainRpc: SetChainRpc;
}
declare const useChainRpcList: (chainId?: ChainId) => RpcList;

declare const useChains: () => ArrayOneOrMore<Chain>;

declare const useConfig: () => Config;

declare const useDefaultCaller: (chainId?: ChainId) => string | undefined;

declare function useAbiMessage(contract: ContractPromise | undefined, message: string): AbiMessage | undefined;

type CallSend<T> = (args?: unknown[], options?: LazyCallOptions) => Promise<DecodedContractResult<T> | undefined>;
interface UseCall<T> {
    send: CallSend<T>;
    isSubmitting: boolean;
}
declare enum CallError {
    ContractUndefined = "Contract is undefined",
    InvalidAbiMessage = "Invalid ABI Message",
    NoResponse = "No response"
}
interface Call<T> extends UseCall<T> {
    result?: DecodedContractResult<T>;
}
declare function useCall<T>(chainContract: ChainContract | undefined, message: string): Call<T>;

declare function useCallSubscription<T>(chainContract: ChainContract | undefined, message: string, args?: unknown[], options?: LazyCallOptions): Omit<Call<T>, 'send'>;

declare enum CodeHashError {
    InvalidHash = "Invalid code hash value."
}
interface CodeHashState {
    codeHash: string;
    set: (hash: string) => void;
    error?: CodeHashError;
    resetState: () => void;
}
declare const useCodeHash: () => CodeHashState;

declare function useContract<T extends ContractPromise = ContractPromise>(address: string, metadata: Record<string, unknown>, chainId?: ChainId): ChainContract<T> | undefined;

declare enum DeployerError {
    NoCodeHashOrWasm = "You must supply either a code hash or metadata containing Wasm.",
    ConstructorNotFound = "The constructor method was not found.",
    InstantiateNotSupportedForApi = "Instantiate method not found for chain API",
    CouldNotCreateTx = "Could not create deploy transaction function",
    TransactionFailed = "Transaction failed.",
    TransactionCancelled = "Transaction cancelled.",
    WalletNotConnected = "Wallet not connected.",
    ApiInstanceNotFound = "Api client not found. Try refreshing the page.",
    InvalidCodeHash = "Invalid code hash."
}
interface DeployData {
    argValues?: Record<string, unknown>;
    value?: Balance;
    metadata?: Abi;
    name: string;
    constructorIndex: number;
    salt: string | Uint8Array | Bytes | null;
    storageDepositLimit: Balance | null;
    gasLimit: WeightV2 | undefined;
    codeHash?: string;
}
type DeploySignAndSend<T> = (metadata: Abi, constructorName?: string, constructorArgs?: Record<string, unknown>, options?: BlueprintOptions & {
    codeHash?: string;
    value?: bigint | BN | string | number;
}, cb?: ContractSubmittableResultCallback) => T;
type DeployTx = SubmittableExtrinsic<'promise', ISubmittableResult>;
interface Deploy<T> {
    dryRun: DeploySignAndSend<Promise<DeployTx | undefined>>;
    signAndSend: DeploySignAndSend<Promise<void>>;
    contractAddress: string | undefined;
    status: TransactionStatus;
    result: ContractSubmittableResult | undefined;
    isSubmitting: boolean;
    error: string | undefined;
    resetState: () => void;
    gasConsumed?: WeightV2;
    gasRequired?: WeightV2;
    storageDeposit?: StorageDeposit;
    willBeSuccessful: boolean;
    wasDeployed: boolean;
    events: EventRecord[];
}
interface AddNotification {
    type: 'ADD_NOTIFICATION';
    notification: Notification;
}
interface RemoveNotification {
    type: 'REMOVE_NOTIFICATION';
    notificationId: string;
}
type Action = AddNotification | RemoveNotification;

declare function useDeployer<T>(chainId?: ChainId): Deploy<T>;

type DryRunResult<T> = DecodedTxResult<T>;
type Send$1<T> = (args?: unknown[], o?: LazyCallOptions) => Promise<DryRunResult<T> | undefined>;
interface DryRun<T> {
    send: Send$1<T>;
    isSubmitting: boolean;
    result?: DryRunResult<T>;
    resolved: Boolean;
    resetState: () => void;
}
declare function useDryRun<T>(chainContract: ChainContract | undefined, message: string): DryRun<T>;

declare const useEventSubscription: (chainContract: ChainContract | undefined) => void;

type EventPayload = {
    createdAt: number;
    name: string;
    args: unknown[];
};
type RemoveEventPayload = {
    eventId: string;
    address: string;
};
type Event = {
    id: string;
} & EventPayload;

interface Events {
    events: Event[];
    removeEvent: (p: RemoveEventPayload) => void;
}
declare const useEvents: (contractAddress: AccountId | string | undefined, filters?: string[]) => Events;

declare enum SalterError {
    InvalidHash = "Invalid salt hash value."
}
interface SalterState {
    salt: string;
    regenerate: () => void;
    set: (salt: string) => void;
    error?: SalterError;
    resetState: () => void;
}
declare const useSalter: () => SalterState;

type Eventable = Pick<Tx<unknown>, 'status'> & Pick<Tx<unknown>, 'result'>;
interface TxEvents {
    resetState: () => void;
    events: EventRecord[];
}
declare const useTxEvents: (tx: Eventable) => TxEvents;

type Send = (params?: unknown[], options?: LazyCallOptions, signerOptions?: Partial<SignerOptions>) => Promise<RuntimeDispatchInfo | undefined>;
interface TxPaymentInfo {
    isSubmitting: boolean;
    result?: RuntimeDispatchInfo;
    send: Send;
    resolved: boolean;
}
declare function useTxPaymentInfo(chainContract: ChainContract | undefined, message: string): TxPaymentInfo;

declare const useUnixMilliToDate: (unixInMilliSeconds: number | undefined) => Date | undefined;

declare const useBalance: (account: WithAddress | undefined, chainId?: ChainId) => DeriveBalancesAccount | undefined;

declare const useTimestampDate: (chainId?: ChainId) => Date | undefined;

declare const useTimestampNow: (chainId?: ChainId) => number | undefined;

declare const useTimestampQuery: (chainId?: ChainId) => QueryableModuleCalls<'promise'> | undefined;

interface IApiProvider {
    api: ApiPromise;
    provider: WsProvider;
}
type IApiProviders = Partial<Record<ChainId, IApiProvider>>;
interface API {
    apis?: IApiProviders;
}

declare const APIContext: React.Context<API>;

declare const APIProvider: React__default.FC<React__default.PropsWithChildren>;

declare const useApis: () => API;
declare const useApi: (chainId?: ChainId) => IApiProvider | undefined;

interface BlockHeader {
    blockNumber: number | undefined;
    header: Header | undefined;
}
type ChainBlockHeaders = Partial<Record<ChainId, BlockHeader>>;

declare const useBlockHeader: (chainId?: ChainId) => BlockHeader | undefined;
declare const useBlockHeaders: () => ChainBlockHeaders;

declare const useChainDecimals: (chainId?: ChainId) => number | undefined;

declare const useTokenSymbol: (chainId?: ChainId) => string | undefined;

type SignAndSendTransfer = (to: string, amount: number, options?: SignerOptions) => void;
interface TransferState {
    signAndSend: SignAndSendTransfer;
    hash: Hash | undefined;
    error: unknown | undefined;
    resetState: () => void;
    isSubmitting: boolean;
}
declare const useTransfer: (chainId?: ChainId) => TransferState | undefined;

declare enum WalletError {
    AccountDisabled = "AccountNotEnabled",
    ConnectionError = "ConnectionError",
    EnableFailed = "EnableFailed",
    NoAccountsEnabled = "NoAccountsEnabled",
    WalletNotInstalled = "WalletNotInstalled"
}
interface WalletState {
    account?: WalletAccount | undefined;
    accounts: WalletAccount[] | undefined;
    connect: (walletName: WalletName) => void;
    disconnect: () => void;
    walletError?: WalletError;
    isConnected: boolean;
    setAccount: (account: WalletAccount) => void;
    getWallets: typeof getWallets;
    getWalletBySource: typeof getWalletBySource;
}
type Wallet = Exclude<ReturnType<typeof getWalletBySource>, undefined>;
type WalletName = string;

declare const useAllWallets: () => Wallet[];

declare const useInstalledWallets: () => Wallet[];

declare const useUninstalledWallets: () => Wallet[];

declare const useWallet: () => WalletState;

type InkConfig = {
    config: ConfigProps;
};
declare const UseInkProvider: React__default.FC<React__default.PropsWithChildren<InkConfig>>;

export { API, APIContext, APIProvider, Action, AddNotification, BlockHeader, Call, CallError, CallSend, ChainContract, CodeHashError, CodeHashState, ContractSubmittableResultCallback, Deploy, DeployData, DeploySignAndSend, DeployTx, DeployerError, DryRun, DryRunResult, Events, IApiProvider, IApiProviders, InkConfig, RemoveNotification, RpcList, SalterError, SalterState, Send$1 as Send, SignAndSendTransfer, TransferState, Tx, UseCall, UseInkProvider, WalletState, useAbiMessage, useAllWallets, useApi, useApis, useBalance, useBlockHeader, useBlockHeaders, useCall, useCallSubscription, useChain, useChainDecimals, useChainRpc, useChainRpcList, useChains, useCodeHash, useConfig, useContract, useDefaultCaller, useDeployer, useDryRun, useEventSubscription, useEvents, useInstalledWallets, useSalter, useTimestampDate, useTimestampNow, useTimestampQuery, useTokenSymbol, useTransfer, useTxEvents, useTxPaymentInfo, useUninstalledWallets, useUnixMilliToDate, useWallet };
