import {
  HALF_A_SECOND,
  useInterval,
  useIsMounted
} from "./chunk-ABVRVYC3.mjs";
import {
  getExpiredItem,
  pseudoRandomId
} from "./chunk-K4CFJTMJ.mjs";
import "./chunk-UT43TYHK.mjs";

// src/notifications/model.ts
var DEFAULT_NOTIFICATIONS = [];

// src/notifications/context.ts
import { createContext } from "react";
var NotificationsContext = createContext({
  notifications: DEFAULT_NOTIFICATIONS,
  config: void 0,
  addNotification: () => null,
  removeNotification: () => null
});

// src/notifications/hooks/useNotifications.ts
import { useContext, useMemo } from "react";
var useNotifications = () => {
  const { addNotification, notifications, removeNotification, config } = useContext(NotificationsContext);
  const chainNotifications = useMemo(() => {
    return notifications ?? [];
  }, [notifications]);
  useInterval(() => {
    if (config?.expiration === 0)
      return;
    const expiredNotifications = getExpiredItem(
      chainNotifications,
      config?.expiration
    );
    for (const notification of expiredNotifications) {
      removeNotification(notification.id);
    }
  }, config?.checkInterval || HALF_A_SECOND);
  return {
    notifications: chainNotifications,
    addNotification,
    removeNotification
  };
};

// src/notifications/hooks/useTxNotifications.ts
import { useEffect } from "react";
function useTxNotifications(tx, chain) {
  const { addNotification } = useNotifications();
  useEffect(() => {
    if (["Ready", "None"].includes(tx.status))
      return;
    addNotification({
      type: tx.status,
      message: tx.status,
      result: tx.result,
      chain
    });
  }, [tx.status]);
}

// src/notifications/reducer.ts
function notificationReducer(state, action) {
  const chainState = state ?? [];
  switch (action.type) {
    case "ADD_NOTIFICATION":
      return [...state, action.notification];
    case "REMOVE_NOTIFICATION": {
      return chainState.filter((n) => n.id !== action.notificationId);
    }
  }
}

// src/notifications/provider.tsx
import React, { useCallback, useReducer } from "react";
var NotificationsProvider = ({ children, config }) => {
  const [notifications, dispatch] = useReducer(
    notificationReducer,
    DEFAULT_NOTIFICATIONS
  );
  const isMounted = useIsMounted();
  const addNotification = useCallback(
    (notification) => {
      if (isMounted()) {
        dispatch({
          type: "ADD_NOTIFICATION",
          notification: {
            ...notification,
            id: pseudoRandomId(),
            createdAt: Date.now()
          }
        });
      }
    },
    [dispatch]
  );
  const removeNotification = useCallback(
    (notificationId) => {
      if (isMounted()) {
        dispatch({
          type: "REMOVE_NOTIFICATION",
          notificationId
        });
      }
    },
    [dispatch]
  );
  return /* @__PURE__ */ React.createElement(
    NotificationsContext.Provider,
    {
      value: { addNotification, notifications, removeNotification, config },
      children
    }
  );
};

// src/notifications/utils/toNotificationLevel.ts
var toNotificationLevel = (type) => {
  switch (type) {
    case "None":
      return "info";
    case "DryRun":
      return "info";
    case "PendingSignature":
      return "info";
    case "Future":
      return "info";
    case "Ready":
      return "info";
    case "Broadcast":
      return "info";
    case "InBlock":
      return "success";
    case "Retracted":
      return "warning";
    case "FinalityTimeout":
      return "error";
    case "Finalized":
      return "success";
    case "Usurped":
      return "error";
    case "Dropped":
      return "error";
    case "Invalid":
      return "warning";
    case "Errored":
      return "error";
    case "WalletConnected":
      return "info";
    case "WalletDisconnected":
      return "info";
    default:
      return "info";
  }
};
export {
  DEFAULT_NOTIFICATIONS,
  NotificationsContext,
  NotificationsProvider,
  toNotificationLevel,
  useNotifications,
  useTxNotifications
};
